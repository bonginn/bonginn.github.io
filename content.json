{"posts":[{"title":"WQS 二分搜","text":"一篇WQS二分搜的筆記，希望能讓自己不要這麼快忘記的個優化技巧。 IntroductionWQS 二分搜又稱Aliens優化，是一個可以將二維的DP問題轉化成一個維度的優化技巧複雜度可以從$O(N^2)$下降到$O(NlogC)$，但題目本身需要一些特性。已知某函數$f(x)$為concave function，且我們有某種演算法可以在線性時間內求出$f(x) - px$的最大值及最大值發生的位置($x_0$)。接下來，我們畫出$p=0 - 5$的Cases :可以發現，$x_0$隨著$p$上升逐漸下降！因此若我們希望找到$f(x)$的最大值且$x&lt;=k$，我們可以對$p$做二分搜，找到最近的$p$使得$f(x) - px$的$x_0$$\\le k$，最後答案就會是演算法的輸出$+ pk$。 Informal Proof至於為什麼當p越大，極值發生位置會越來越前面，簡單的證明如下：當$f(x)$極值發生時的必要條件是$\\nabla f(x) = 0$$\\nabla (f(x) - px) = \\nabla f(x) - \\nabla px = \\nabla f(x) - p = 0$已知$f(x)$是concave，因此 $\\nabla f(x)$ 遞減因此當$p \\uparrow$，$x$必須越來越小。然而，WQS真正困難的部分其實是證明$f(x)$是concave的，很多時候看到題目都會靠直覺猜它是concave，然後直接使用此性質（就像猜某個greedy方式會是最佳解）。 Intuition我覺得WQS二分搜有一個很好的intuition：$f(x)$是某件事做了$x$次後得到的值，$p$就可以當作每做一次所需的成本，當成本($p$)越大，我們就不能做太多次操作（若我們的目標是maximize $f(x)$）。因此！理所當然當$p$越大，$x_0$就會越小。 Application直接來看一題很經典的WQS二分的題目AI-666 賺多少：題目敘述：給定$n$天股票價格，求只能交易$k$次的情況下最多能賺多少錢？（假設最多同時只能持有一張股票）這題有一個很簡單的dp解：$dp0[i][j]$表示在第$i$天，交易了$j$次且當下沒有股票的最佳解$dp1[i][j]$表示在第$i$天，交易了$j$次且當下持有股票的最佳解轉移式：$dp0[i][j] = max(dp0[i-1][j], dp1[i-1][j-1] + a[i])$$dp1[i][j] = max(dp1[i-1][j], dp0[i-1][j] - a[i])$最後答案就是$dp0[n][k]$。但很明顯，此做法的時間、空間複雜度為$O(n^2)$。嘗試將問題轉換成「不限制交易次數」，我們可以發現轉移式就會變成：$dp0[i] = max(dp0[i-1], dp1[i-1] + a[i])$$dp1[i] = max(dp1[i-1], dp0[i-1] - a[i])$其中，$dp0[i]$表示在第$i$天，當下沒有股票的最佳解，$dp1[i]$表示在第$i$天，當下持有股票的最佳解。接著，我們嘗試將每次交易都增加一個$p$元的手續費，此時轉移式變成：$dp0[i] = max(dp0[i-1], dp1[i-1] + a[i])$$dp1[i] = max(dp1[i-1], dp0[i-1] - a[i] - p)$我們可以在$O(n)$的時間解決這個「有手續費且沒有交易次數限制」的問題。最後，我們可以對$p$做二分搜找到某個$p$，使得發生最大值時的交易次數$\\leq k$最終答案就會是此演算法的輸出$+ pk$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define int long long#define ll long long#define pb push_back#define sz(x) (x).size()#define all(x) (x).begin(), (x).end()#define fastio cin.tie(0); ios_base::sync_with_stdio(false);using namespace std;const int maxn = 2e6+5;const int mod = 1e9+7; // 998244353;const ll inf = 1ll &lt;&lt; 61;typedef pair&lt;int,int&gt; P;int n, k;int a[maxn];P dp0[maxn], dp1[maxn];void init(){ dp0[0] = P(0, 0); dp1[0] = P(-inf, 0);}P cal(int p){ init(); P res = {0, inf}; for(int i=1;i&lt;=n;i++){ // 沒股票 if(dp0[i-1] &gt; P(dp1[i-1].first + a[i] - p, dp1[i-1].second - 1)) dp0[i] = dp0[i-1]; else dp0[i] = P(dp1[i-1].first + a[i] - p, dp1[i-1].second - 1); // 有股票 if(dp1[i-1] &gt; P(dp0[i-1].first - a[i], dp0[i-1].second)) dp1[i] = dp1[i-1]; else dp1[i] = P(dp0[i-1].first - a[i], dp0[i-1].second); res = max(res, dp0[i]); } return res;}void solve(){ cin &gt;&gt; n &gt;&gt; k; for(int i=1;i&lt;=n;i++) cin &gt;&gt; a[i]; int l = 0, r = 5e4; P res = cal(0); int pp; if(-res.second &lt;= k){ cout &lt;&lt; res.first; return; } while(l &lt;= r){ int mid = (l + r) / 2; res = cal(mid); if(-res.second &gt; k){ pp = mid; l = mid + 1; } else{ r = mid - 1; } } cout &lt;&lt; cal(pp+1).first + (pp+1) * k;}signed main(){fastio int T = 1; //cin &gt;&gt; T; while(T--){ solve(); }} 在TIOJ上要稍微壓一點常數（e.g. 二分搜範圍） WQA二分搜的過程其實有不少細節，請未來的我自行體會。但就結論而言，一個簡單且可以避免錯誤的方法是「找最大的$p$使得最後的交易次數不滿足題目限制」最後我們所需$p$就會是$p+1$(如果是離散的話)。 Related Problems 美食博覽會 (k 值加大版)Subarray SquaresTree IE2. Guard Duty (medium)F. New Year and Handle ChangeE. Gosha is hunting","link":"/2025/01/08/WQS%E4%BA%8C%E5%88%86%E6%90%9C/"},{"title":"TIOJ 2070","text":"Solution of TIOJ 2070 - Special Judge。 Description給你由小寫英文字母組成的字串$X$，請判斷是不是每一個前$K$個英文字母的子集都是$X$的子序列。 Observation 1「前$k$個英文字母的『子集』的排列」都是子序列，其實就相當於要你判斷「是否前$k$個英文字母的的排列」都是子序列（abc的所有排列都是，那a, b, c, ab, ac, bc, abc也當然都會是）。 Observation 2範圍：$K \\le 20$ $\\rightarrow$位元DP！ Solution定義dp[S] = 當狀態為S時，字串所需的最短長度能夠使得滿足題目的要求，當dp[S]為n+1時，表示狀態S無法滿足。另外定義pos[i][j]表示在位置j往右出現字元i最近的位置，-1表示右邊找不到i。轉移式：$dp[i + (1 &lt;&lt; j)] = max(dp[i + (1 &lt;&lt; j)], pos[j][dp[i]]);$轉移過程中只要有出現了任何一個pos = -1就輸出$No$，否則就輸出$Yes$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;#define int long long#define pb push_back#define all(x) (x).begin(), (x).end()#define fastio cin.tie(0); ios_base::sync_with_stdio(false);#define INF 1e15+9using namespace std;const int maxn = 2e5+5;const int MOD = 1e9+7; // 998244353;typedef pair&lt;int,int&gt; P;void solve(){ int k; string s; cin &gt;&gt; k &gt;&gt; s; char myChar[1005] = {}; for(int i=1;i&lt;=s.size();i++) myChar[i] = s[i-1]; int pos[50][1001]; for(int i=0;i&lt;k;i++){ int curPos = -1; for(int j=s.size();j&gt;=0;j--){ pos[i][j] = curPos; if(myChar[j] - 'a' == i) curPos = j; } } int S = (1 &lt;&lt; k); int dp[S+5] = {}; // dp[s] = 狀態s時, 會往右延伸到哪裡, INF表沒辦法 for(int i=0;i&lt;S;i++){ for(int j=0;j&lt;k;j++){ // 看看哪些沒在狀態i裡面 if((i &gt;&gt; j) % 2 == 0){ int nearest = pos[j][dp[i]]; if(nearest == -1){ cout &lt;&lt; &quot;No&quot; &lt;&lt; '\\n'; return; } dp[i + (1 &lt;&lt; j)] = max(dp[i + (1 &lt;&lt; j)], pos[j][dp[i]]); } } } cout &lt;&lt; &quot;Yes&quot; &lt;&lt; '\\n';}signed main(){fastio int T = 1; cin &gt;&gt; T; while(T--){ solve(); }} Bonus這一題的前身是「構造一個最短字串滿足此性質」，此題是一個co-NP-complete的問題目前能找到的最短且有系統的構造方法如下：12345678for(int i=1;i&lt;=k * k - 2 * k + 4;i++){ if(i &lt;= k) cout &lt;&lt; (char)('a' + i - 1); else if(i &gt; k &amp;&amp; (i - 2) % (k - 1) == 0) cout &lt;&lt; 'a'; else cout &lt;&lt; (char)((int)floor((i - 1) * (k - 2) / (k - 1)) % (k - 1) + 2 + 'a' - 1);}長度：$k^2 - 2k + 4$","link":"/2024/08/24/tioj2070/"},{"title":"我的第一篇貼文","text":"這是一篇測試用的文章。 首先先來測試一些基本的文字嗨，你好。I am Chung Pang Chun, and the handle I often use is bonginn.1 + 1 = 2 測試數學式$x^n + y^n = z^n$ \\begin{equation} \\begin{aligned} \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} \\end{aligned}\\end{equation} 測試code12345678#include &lt;iostream&gt;using namespace std;int main(){ int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b;} 測試圖片 測試連結codeforces","link":"/2024/08/24/test/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"}],"categories":[{"name":"Note","slug":"Note","link":"/categories/Note/"},{"name":"Solution","slug":"Solution","link":"/categories/Solution/"}],"pages":[{"title":"About Me","text":"My name is Pang-Chun, Chung, and I am currently a junior at Department of Compuetr Science, National Yang Ming Chiao Tung University (NYCU). I’m interested in competitive programming, machine learning, and deep learning. I hope I can share what I have learned with my future self through this blog.If you have any questions regarding this blog posts, feel free to contact me via this email!","link":"/about/index.html"}]}